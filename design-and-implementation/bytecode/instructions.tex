\section{Instructions}

Each instruction exists of four bytes: one byte for the opcode and three bytes
for the argument.

How the argument is interpreted depends on the opcode it belongs to. If
it is signed, it is represented in two's complement.

\begin{tabular}{llp{7.6cm}}
\bfseries{Type} & \bfseries{Signed?} & \bfseries{Explanation} \\ \hline
Index & No & A numerical reference to one of the literals (see section \ref{literals}), starting at 0. \\
Offset & Yes & An offset to another code location in the current module. In this case, 0 refers to the next instruction. \\
Number & Yes & An integer value, available to Déjà Vu as a number. \\
None & N/A & Some opcodes do not take arguments. These three bytes will be ignored. \\
\end{tabular}

\begin{tabular}{llll}
\bfseries{Opcode} & \bfseries{Function} & \bfseries{Argument type} & \bfseries{See page} \\ \hline
0x00 & PUSH\textunderscore{}LITERAL & Index & \pageref{sec:push-literal} \\
0x01 & PUSH\textunderscore{}INTEGER & Number & \pageref{sec:push-integer} \\
0x02 & PUSH\textunderscore{}WORD & Index & \pageref{sec:push-word} \\
0x03 & SET & Index & \pageref{sec:set} \\
0x04 & SET\textunderscore{}LOCAL & Index & \pageref{sec:set-local} \\
0x05 & SET\textunderscore{}GLOBAL & Index & \pageref{sec:set-global} \\
0x06 & GET & Index & \pageref{sec:get} \\
0x07 & GET\textunderscore{}GLOBAL & Index & \pageref{sec:get-global} \\
0x10 & JMP & Offset & \pageref{sec:jmp} \\
0x11 & JMPZ & Offset & \pageref{sec:jmpz} \\
0x12 & RETURN & None & \pageref{sec:return} \\
0x13 & RECURSE & None & \pageref{sec:recurse} \\
0x14 & JMPEQ & Offset & \pageref{sec:jmpeq} \\
0x15 & JMPNE & Offset & \pageref{sec:jmpne} \\
0x20 & LABDA & Offset & \pageref{sec:labda} \\
0x21 & ENTER\textunderscore{}SCOPE & None \\
0x22 & LEAVE\textunderscore{}SCOPE & None \\
0x30 & NEW\textunderscore{}LIST & None \\
0x31 & POP\textunderscore{}FROM & None \\
0x32 & PUSH\textunderscore{}TO & None \\
0x33 & PUSH\textunderscore{}THROUGH & None \\
0x40 & DROP & None \\
0x41 & DUP & None \\
0x42 & SWAP & None \\
0x43 & ROT & None \\
0x44 & OVER & None \\
0x50 & LINE\textunderscore{}NUMBER & Number \\
0x52 & SOURCE\textunderscore{}FILE & Index \\
0x60 & ENTER\textunderscore{}ERRHAND & Offset \\
0x61 & LEAVE\textunderscore{}ERRHAND & None \\
0x62 & RAISE & None \\
0x63 & RERAISE & None \\
0x70 & NEW\textunderscore{}DICT & None \\
0x71 & HAS\textunderscore{}DICT & None \\
0x72 & GET\textunderscore{}DICT & None \\
0x73 & SET\textunderscore{}DICT & None \\
\end{tabular}

\subsection{PUSH\textunderscore{}LITERAL}
\label{sec:push-literal}
This opcode pushes a literal value to the stack.

\subsection{PUSH\textunderscore{}INTEGER}
\label{sec:push-integer}
This opcode pushes a literal integer to the stack. It performs the same
basic function as PUSH\textunderscore{}LITERAL, except that is narrower
in scope (it only handles integers representable in 24 bits) and avoids
an entry in the literals table, which would be relatively expensive. A
conforming compiler can choose not to generate PUSH\textunderscore{}INTEGER
and instead add all literal integers to the literals table and generate
PUSH\textunderscore{}LITERAL instructions instead.

\subsection{PUSH\textunderscore{}WORD}
\label{sec:push-word}
This opcode first performs the same functionality as GET and then, if
the value retrieved is a function, that function is called.

\subsection{SET}
\label{sec:set}
This opcode retrieves an ident from the literals table and pops a
value from the stack. It then goes upward from the current scope,
stopping if it finds a definition of the ident in question. It then
assigns the value to the ident in that scope. If the global scope is
reached without finding a definition for the ident, an assignment in the
global scope is made.

\subsection{SET\textunderscore{}LOCAL}
\label{sec:set-local}
This opcode retrieves an ident from the literals table and pops a
value from the stack. It then assigns the value to the ident in the
current scope.

\subsection{SET\textunderscore{}GLOBAL}
\label{sec:set-global}
This opcode retrieves an ident from the literals table and pops a
value from the stack. It then assigns the value to the ident in the
global scope.

\subsection{GET}
\label{sec:get}
This opcode retrieves an ident from the literals table. It then goes
upward from the current scope, stopping if it finds a definition of the
ident in question. It then pushes the value from the ident in that scope
to the stack. If the global scope is reached without finding a
definition for the ident, a \verb!name-error! exception is thrown.

\subsection{GET\textunderscore{}GLOBAL}
\label{sec:get-global}
This opcode retrieves an ident from the literals table. It then looks up
the definition of that ident in the global scope and pushes the value to
the stack. If the global scope has no definition for the ident, a
\verb!name-error! exception is thrown.

\subsection{JMP}
\label{sec:jmp}
An unconditional jump. The argument is the relative position where the
control will jump to before executing the next instruction.

\subsection{JMPZ}
\label{sec:jmpz}
A conditional jump. A value is popped from the stack. If the value is
a false one (see the language reference for an overview of truth values
for the various types), the jump is made. The argument is the relative
position where the control will jump to before executing the next
instruction.

\subsection{RETURN}
\label{sec:return}
Returns from the current function. Closes all scopes belonging to the
current function call, including error handlers.

\subsection{RECURSE}
\label{sec:recurse}
Similar to RETURN, except that it also ``restarts'' the function
(keeping the original function scope), implementing a form of tail call
optimization.

\subsection{JMPEQ}
\label{sec:jmpeq}
An conditional jump. Two values are popped from the stack. If the values
are equal (see the language reference for an overview of equality for
the various types), the jump is made. The argument is the relative
position where the control will jump to before executing the next
instruction.

\subsection{JMPNE}
\label{sec:jmpne}
An conditional jump. Two values are popped from the stack. If the values
are \emph{not} equal (see the language reference for an overview of
equality for the various types), the jump is made. The argument is the
relative position where the control will jump to before executing the
next instruction.

\subsection{LABDA}
\label{sec:labda}
Creates an anonymous function and pushes it to the stack. The current
scope will be the parent scope of that function. The function will begin
execution in the next instruction when called. After pushing the
function to the stack, the control flow works as it would have done had
the instruction been JMP.
